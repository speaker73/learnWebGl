{"version":3,"file":"game.js","sources":["webpack:///webpack/bootstrap","webpack:///app/Game.js","webpack:///app/components/Second/Second.js","webpack:///app/components/Second/index.js","webpack:///./app/components/Second/vertexShader2d.glsl","webpack:///app/components/index.js","webpack:///./app/fragmentShader.glsl","webpack:///app/index.js","webpack:///./app/vertexShader.glsl","webpack:///engine/Component.js","webpack:///engine/EngineWebGl.js","webpack:///engine/compileShader.js","webpack:///engine/createProgram.js","webpack:///engine/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./app/index.js\");\n","import {Component, compileShader, createProgram} from \"engine\";\r\nimport vertexShader from './vertexShader.glsl';\r\nimport fragmentShader from './fragmentShader.glsl';\r\nimport { webGl } from 'engine/EngineWebGl';\r\n\r\nimport {Second} from './components';\r\n\r\n\r\nexport default class Game extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        console.log(webGl)\r\n        this.shaders = {\r\n            vertexShader:compileShader(webGl.VERTEX_SHADER, vertexShader),\r\n            fragmentShader:compileShader(webGl.FRAGMENT_SHADER, fragmentShader)\r\n        };\r\n        this.program = createProgram([this.shaders.vertexShader, this.shaders.fragmentShader]);\r\n\r\n        const positionAttributeLocation = webGl.getAttribLocation(this.program, \"a_position\");\r\n        console.log(positionAttributeLocation);\r\n        const positionBuffer = webGl.createBuffer();\r\n        console.log(positionBuffer);\r\n        webGl.bindBuffer(webGl.ARRAY_BUFFER, positionBuffer);\r\n        const positions = [\r\n            0, 0,\r\n            0, 0.5,\r\n            0.7, 0,\r\n        ];\r\n        webGl.bufferData(webGl.ARRAY_BUFFER, new Float32Array(positions), webGl.STATIC_DRAW);\r\n\r\n        //render\r\n        webGl.viewport(0, 0, webGl.canvas.width, webGl.canvas.height);\r\n        // очищаем canvas\r\n        webGl.clearColor(0, 0, 0, 0);\r\n        webGl.clear(webGl.COLOR_BUFFER_BIT);\r\n// говорим использовать нашу программу (пару шейдеров)\r\n        console.log(this.program);\r\n        webGl.useProgram(this.program);\r\n        webGl.enableVertexAttribArray(positionAttributeLocation);\r\n        // Привязываем буфер положений\r\n        webGl.bindBuffer(webGl.ARRAY_BUFFER, positionBuffer);\r\n\r\n// Указываем атрибуту, как получать данные от positionBuffer (ARRAY_BUFFER)\r\n        const size = 2;          // 2 компоненты на итерацию\r\n        const type = webGl.FLOAT;   // наши данные - 32-битные числа с плавающей точкой\r\n        const normalize = false; // не нормализовать данные\r\n        const stride = 0;        // 0 = перемещаться на size * sizeof(type) каждую итерацию для получения следующего положения\r\n        const offset = 0;        // начинать с начала буфера\r\n        console.log(positionAttributeLocation, size, type, normalize, stride, offset);\r\n        webGl.vertexAttribPointer(positionAttributeLocation, size, type, normalize, stride, offset);\r\n\r\n        const primitiveType = webGl.TRIANGLES;\r\n        // const offset = 0;\r\n        const count = 3;\r\n        webGl.drawArrays(primitiveType, offset, count);\r\n    }\r\n    render(){\r\n       return [\r\n           new Second({title:'Second'})\r\n       ]\r\n    }\r\n}","import {Component, createProgram, compileShader} from \"engine\";\r\nimport { webGl } from 'engine/EngineWebGl';\r\n\r\nimport vertexShader2d from \"./vertexShader2d.glsl\";\r\n\r\nexport default class Second extends Component{\r\n    constructor(props){\r\n        super(props);\r\n\r\n        this.shaders = {\r\n            vertexShader2d:compileShader( webGl.VERTEX_SHADER, vertexShader2d)\r\n        };\r\n        this.program = createProgram([this.shaders.vertexShader2d]);\r\n\r\n        console.log(this.program);\r\n        const resolutionUniformLocation =  webGl.getUniformLocation(this.program, \"u_resolution\");\r\n\r\n        const positions = [\r\n            10, 20,\r\n            80, 20,\r\n            10, 30,\r\n            10, 30,\r\n            80, 20,\r\n            80, 30,\r\n        ];\r\n\r\n        webGl.bufferData(webGl.ARRAY_BUFFER, new Float32Array(positions), webGl.STATIC_DRAW);\r\n        webGl.useProgram(this.program);\r\n\r\n        // установка разрешения\r\n        webGl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);\r\n\r\n        const primitiveType = webGl.TRIANGLES;\r\n        const offset = 0;\r\n        const count = 6;\r\n        webGl.drawArrays(primitiveType, offset, count);\r\n    }\r\n    render(){\r\n\r\n    }\r\n}\r\n","import Second from './Second';\r\nexport default Second;","module.exports = \"attribute vec2 a_position;\\r\\nuniform vec2 u_resolution;\\r\\n\\r\\n void main() {\\r\\n    // преобразуем положение в пикселях к диапазону от 0.0 до 1.0\\r\\n    vec2 zeroToOne = a_position / u_resolution;\\r\\n\\r\\n    // преобразуем из 0->1 в 0->2\\r\\n    vec2 zeroToTwo = zeroToOne * 2.0;\\r\\n\\r\\n    // преобразуем из 0->2 в -1->+1 (пространство отсечения)\\r\\n    vec2 clipSpace = zeroToTwo - 1.0;\\r\\n\\r\\n    gl_Position = vec4(clipSpace, 0, 1);\\r\\n }\"","import Second from './Second';\r\n\r\nexport {\r\n    Second\r\n}","module.exports = \" // фрагментные шейдеры не имеют точности по умолчанию, поэтому нам необходимо её\\r\\n  // указать. mediump подойдёт для большинства случаев. Он означает \\\"средняя точность\\\"\\r\\n  precision mediump float;\\r\\n \\r\\n  void main() {\\r\\n    // gl_FragColor - специальная переменная фрагментного шейдера.\\r\\n    // Она отвечает за установку цвета.\\r\\n    gl_FragColor = vec4(1, 0, 0.5, 1); // вернёт красновато-фиолетовый\\r\\n  }\\r\\n \"","import { EngineWebGl } from 'engine';\r\nimport Game from './Game';\r\n\r\nEngineWebGl.render(Game, document.getElementById('game') );\r\n","module.exports = \"// атрибут, который будет получать данные из буфера\\r\\nattribute vec4 a_position;\\r\\n\\r\\n// все шейдеры имеют функцию main\\r\\nvoid main() {\\r\\n\\r\\n  // gl_Position - специальная переменная вершинного шейдера,\\r\\n  // которая отвечает за установку положения\\r\\n  gl_Position = a_position;\\r\\n}\"","import compileShader from \"./compileShader\";\r\n\r\nexport default class Component {\r\n   constructor(...children){\r\n       this.children = children;\r\n   }\r\n   render(gl){\r\n       this.children.forEach(child=>{\r\n           child.render(gl);\r\n       })\r\n   }\r\n}","let webGl;\r\n\r\nclass EngineWebGl {\r\n   static render(Game, canvas){\r\n       webGl = canvas.getContext('webgl');\r\n\r\n      const game = new Game();\r\n      game.render();\r\n   }\r\n}\r\n\r\nexport {\r\n   webGl,\r\n   EngineWebGl\r\n}\r\n\r\n","import { webGl } from './EngineWebGl';\r\n\r\nexport default (type, source)=>{\r\n    const shader = webGl.createShader(type);   // создание шейдера\r\n    webGl.shaderSource(shader, source);      // устанавливаем шейдеру его программный код\r\n    webGl.compileShader(shader);             // компилируем шейдер\r\n    const success = webGl.getShaderParameter(shader, webGl.COMPILE_STATUS);\r\n    if (success) {                        // если компиляция прошла успешно - возвращаем шейдер\r\n        return shader;\r\n    }\r\n    webGl.deleteShader(shader);\r\n}","import { webGl } from './EngineWebGl';\r\n\r\nexport default (shaders)=> {\r\n\r\n    const program = webGl.createProgram();\r\n    shaders.forEach(shader=>{\r\n        console.log({shader})\r\n        webGl.attachShader(program, shader);\r\n    });\r\n    webGl.linkProgram(program);\r\n    const success = webGl.getProgramParameter(program, webGl.LINK_STATUS);\r\n    console.log(success);\r\n    if (success) {\r\n        return program;\r\n    }\r\n    setTimeout(()=>{\r\n        console.log( webGl.validateProgram(program));\r\n\r\n    }, 4000)\r\n    //webGl.deleteProgram(program);\r\n}","import Component from './Component';\r\nimport {EngineWebGl} from \"./EngineWebGl\";\r\nimport compileShader from './compileShader';\r\nimport createProgram from './createProgram';\r\n\r\nexport {\r\n    Component,\r\n    EngineWebGl,\r\n    compileShader,\r\n    createProgram\r\n}"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AClFA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA9CA;AA8CA;AACA;;;AAAA;AACA;AACA;AAAA;AAEA;;;;AApDA;AACA;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AAEA;AACA;AADA;AAGA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AA9BA;AA8BA;AACA;;;AAAA;;;;AAhCA;AACA;;;;;;;;;;;;;;;;;;;;ACNA;AACA;;;AAAA;;;;;;;;;;;;ACDA;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;;;;;;;;;;;;ACDA;;;;;;;;;;;;;;ACAA;AACA;AAAA;AACA;;;AACA;;;;;;;;;;;ACHA;;;;;;;;;;;;;;;;;;;ACAA;AACA;;;;;;;;;AACA;;;AACA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;;;AAEA;;;;;;;;;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AADA;AACA;AACA;AADA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;A","sourceRoot":""}